---
created: 2017-02-27T17:00Z
title: Software Tools
type: page
updated: 2020-08-31T11:00Z
---

Choosing the right software for the job can be a painstaking process. On all of the major platforms, there is a plethora of tools available for most tasks. Picking the first thing that comes along without evaluating all of the options might save some time up front, but it will lead to headaches further on down the line.

I am critical of all software that I use. I will try all of the alternatives and weigh their pros and cons before deciding upon which one to use. This takes time, and I often end up purchasing software that I will not use in the long-run just to test it out, but it leads me to being happier with the choices I make. I know I am using the best tool for both myself and the task at hand.

There are five criterion that I make sure all of the software I use meets. If at anytime something I am evaluating does not meet one of these rules, I will not consider it for long-term use.

### Available across all platforms that I need it on

This point might seem obvious, but what I mean is that for any one task, I am using the same piece of software across all of the platforms that I am doing that task on. By restricting myself to the same application on all platforms, I am able to make sure that I have the same feature-set available at all times. Having to switch platforms just to complete one small part of a task is not ideal.

Sometimes, this requires me to evaluate what the needs of the task are on different platforms. What makes sense on iOS might not make sense on macOS. This forces me to consider which platforms I want to complete the task on. For example, if I only write while on macOS, having a writing application on iOS might not be required.

### Long and continued maintenance history

Outdated software will cause problems in the long-run, and it prevents you from taking advantage of new advances in computing.

Software that has a long maintenance history indicates that updates will continue into the future. Software with a successful business model and/or active and large open-source community around it is likely to be maintained for a number of years still. Despite being 40 years old, one of the reason [Emacs](https://en.wikipedia.org/wiki/Emacs) is popular is that it sees active development.

A long maintenance history is important for software that takes a lot of practice to use. If something takes a few months to master, you don't want to be stuck without recourse should a critical bug be discovered. And being forced to have to weigh spending as much time learning new tools or continuing to use the old antiquated software can be a difficult choice.

Finally, modern security practices mandate using software that is up-to-date and patched. Without it, bugs and exploits could allow catastrophic data loss.

When programs stop being maintained, they tend to fall off the radar. When looking for new tools, I will not consider the one that was last updated 5 years ago. But continual evaluation of all current software is important to. Any application that stops being updated should be considered for removal from use, before a problem arises.

### The more complicated the task, the more popular it needs to be

If a program is highly technical but has a small user-base, there's a risk it will be discontinued at some point. Highly technical software takes more knowledge and time to maintain. If there is not a financial incentive or large open-source user-base to help contribute, these applications can die if the creators do not feel that updating it is worthwhile.

The more popular an application is, the higher the likelihood of it being available on multiple platforms.

### Operates on open formats

A big danger in saving data in proprietary formats is that one day, they might not be accessible. Proprietary formats might require reverse engineering just to be able to read them. This can lead to different applications handling the files in different ways, leading to inconsistencies in how the data is viewed and potential data loss.

When I was an undergraduate and graduate student, most of my papers were written using [Bean](https://en.wikipedia.org/wiki/Bean_(software)), which saves files in the [Rich Text Format](https://en.wikipedia.org/wiki/Rich_Text_Format), and [Apple Pages](https://en.wikipedia.org/wiki/Pages_(word_processor)), which uses its own proprietary format. Both formats have different levels of support. Rich Text has multiple versions, and not all applications support each version, opening up the potential for data loss. And few programs support reading the Pages format, let alone saving to it.

To prevent myself from losing out on these papers, I have been converting them to plain text so that the content is saved, as well as [PDF](https://en.wikipedia.org/wiki/Portable_Document_Format) exports so that I can see how the original paper was formatted. Doing this while I have access to Pages is important, as [LibreOffice](https://en.wikipedia.org/wiki/LibreOffice) seems to be the only viable way to open them outside of the Apple ecosystem, and support for the format is both limited and only recently added.

Making sure all future documents are saved in an open format is a top priority for me. I do not want to risk 20 or 30 years from now not having the ability to open something that was at some point important to me. Right now, this means [plain text files](https://en.wikipedia.org/wiki/Plain_text) or [HTML](https://en.wikipedia.org/wiki/HTML) files, as support for them is long-standing and will continue well into the future.

### Efficient computer usage

The final piece of the software puzzle is using applications that are efficient at what they do. This refers to two forms of efficiency.

The first is that the interface is well designed. If I feel like I am fighting against the interface and not getting work done, then it is a tool I do not want to use. This does not mean that complicated tools that require practice are out of the question, just that there needs to be a reason for being complicated, with obvious gains that could not be done with a more simplistic interface.

The second part is that the program makes good use of computer resources. Today, this means not using anything that relies on web technologies for their logic and rendering. These applications are slower and use more memory than something programmed natively. This can lead to worsened battery life in mobile devices, and general slowness on all but the fastest desktop devices.

### Finding the balance between searching for tools and using them

This is my criteria for all software that I use. When evaluating new applications, if it does not meet all of these criteria, I rule out its use. I also do not constantly try to replace my tools. To be sure, I keep up with new tools released, but given the first point of using something that has been around for a while, I will not switch to it right away. It is easy to fall into the trap of constantly learning new tools instead of using them to do actual work.

## Cross-platform Tools

### eBook Reader

**Name**: [iBooks](https://www.apple.com/ibooks/)<br>
**OS**: iOS, macOS<br>
**Used Since**: April, 2010<br>
**Previously Used**: [Google Play Books](https://en.wikipedia.org/wiki/Google_Play_Books)

### E-mail

**Name**: [Mail](https://en.wikipedia.org/wiki/Apple_Mail)<br>
**OS**: iOS, macOS<br>
**Used Since**: March, 2015<br>
**Previously Used**: [Gmail](https://en.wikipedia.org/wiki/Gmail)

### Password Manager

**Name**: [1Password](https://1password.com)<br>
**OS**: iOS, macOS<br>
**Used Since**: August, 2013

### RSS Reader

**Name**: [NetNewsWire](http://netnewswireapp.com)<br>
**OS**: iOS, macOS<br>
**Used Since**: March, 2020<br>
**Previously Used**: [Reeder](http://reederapp.com), [Unread](http://supertop.co/unread/)

### Task Management

**Name**: [Things](https://culturedcode.com/things/)<br>
**OS**: iOS, macOS<br>
**Used Since**: December, 2018<br>
**Previously Used**: [OmniFocus](https://www.omnigroup.com/omnifocus), [Reminders](https://en.wikipedia.org/wiki/Reminders_(Apple))

### Writing

**Name**: [iA Writer](https://ia.net/writer/)<br>
**OS**: iOS, macOS<br>
**Used Since**: January, 2014<br>
**Previously Used**: [Bean](http://www.bean-osx.com/Bean.html), [OpenOffice.org](https://en.wikipedia.org/wiki/OpenOffice.org), [Pages](https://www.apple.com/pages/), [Scrivener](http://www.literatureandlatte.com/scrivener.php)

## iOS Tools

### Podcasts

**Name**: [Overcast](https://overcast.fm)<br>
**Used Since**: July, 2014<br>
**Previously Used**: [Apple Podcasts](https://support.apple.com/en-us/HT201859), [iTunes](https://www.apple.com/itunes/)

### Sleep Tracking

**Name**: [AutoSleep](http://autosleep.tantsissa.com)<br>
**Used Since**: December, 2016<br>
**Previously Used**: [Sleep Cycle](https://www.sleepcycle.com), [Sleep++](https://david-smith.org/apps/)

## macOS Tools

### Code Editor

**Name**: [Sublime Text](https://www.sublimetext.com)<br>
**Used Since**: July, 2011<br>
**Previously Used**: [Atom](https://atom.io), [Emacs](https://www.gnu.org/software/emacs/), [TextWrangler](http://www.barebones.com/products/textwrangler/), [Neovim](https://neovim.io), [Visual Studio Code](https://code.visualstudio.com)

### Command-Line Terminal

**Name**: [iTerm](https://www.iterm2.com)
**Used Since**: December, 2007<br>
**Previously Used**: [Alacritty](https://github.com/jwilm/alacritty), [Terminal](https://en.wikipedia.org/wiki/Terminal_(macOS))<br>

### File Backup

**Name**: [Arq](https://www.arqbackup.com)<br>
**Used Since**: July, 2016<br>
**Previously Used**: [Time Machine](https://en.wikipedia.org/wiki/Time_Machine_(macOS))

### Image Editing

**Name**: [Pixelmator Pro](https://www.pixelmator.com/pro/)<br>
**Used Since**: November, 2019<br>
**Previously Used**: [Adobe Photoshop CS6](https://en.wikipedia.org/wiki/Adobe_Photoshop), [GIMP](https://www.gimp.org), [Pixelmator](http://www.pixelmator.com)

### Integrated Development Environment (C, Swift)

**Name**: [Xcode](https://developer.apple.com/xcode/)<br>
**Used Since**: June, 2018
