---
category: programming
created: 2017.04.06:0845
title: The Krueger Report - Project Euler In Swift
type: page
updated: 2017.04.06:0845
---

# Project Euler In Swift

My favorite way to learn a new programming language is using problems from [Project Euler](https://projecteuler.net). These problems are largely math problems, with a smattering of cryptography and other such topics. Many of the problems can be brute forced, but even on modern CPUs, these can take minutes or hours to solve. To truly solve the problem, one must come up with an efficient algorithm, and most are solvable in only a few seconds of time.

My goal is to work on one problem from Project Euler every week. I will post my code on this page. The code will be formatted so that each bit can function independently. A good way to see this is to load it into [Swift Playgrounds](https://developer.apple.com/swift/playgrounds/) or [Xcode](https://en.wikipedia.org/wiki/Xcode) and run the code.

Note: The problems, as presented by Project Euler, have definitive inputs with a single desired output. Despite this, I still setup my code in the form of functions that can be generalized with any input and still provide the appropriate answer.

## Problem 001 - Multiples Of 3 And 5

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

	func p001(input: Int = 1000) -> Int {
		var output = 0

		for number in stride(from: 3, to: input - 1, by: 3) { output += number }
		for number in stride(from: 5, to: input - 1, by: 5) { output += number }
		for number in stride(from: 15, to: input - 1, by: 15) { output -= number }

		return output
	}

## Problem 002 - Even Fibonacci Numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci Sequence whose values do not exceed four million, find the sum of the even-valued terms.

	func p002(input: Int = 4_000_000) -> Int {
		var output = 0
		var number1 = 0
		var number2 = 2
		var temp: Int

		while number2 < input {
			output += number2
			temp = (4 * number2) + number1
			number1 = number2
			number2 = temp
		}

		return output
	}

## Find All Prime Factors Of A Number

This is necessary for Problem 003. This code returns an Array of Ints that includes all [prime factors](https://en.wikipedia.org/wiki/Prime_factor) of the tested number. It is implemented as an extension of the Int type, so that any Int can easily return its own prime factors using the example syntax 42.primeFactors or number.primeFactors.

	extension Int {
		var primeFactors: [Int] {
			var output: [Int] = []
			var counter = 2
			var max = self

			while counter <= max {
				if max % counter == 0 {
					max /= counter
					output.append(counter)
				} else {
					counter += 1
				}
			}

			return output
		}
	}

## Problem 003 - Largest Prime Factor

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143?

	func p003(input: Int = 600_851_475_143) -> Int {

		if let number = input.primeFactors.last {
			return number
		} else {
			return 0
		}

	}

## Testing Whether A String Is A Palindrome

Figuring out whether a string is a [palindrome](https://en.wikipedia.org/wiki/Palindrome) is necessary for Problem 004. This String Extension compares the string's first and last characters, pair by pair. The result is delivered as a Boolean. Any string can be checked as a palindrome by invoking the syntax word.isPalindrome. Ints can be checked by casting the Int as a String. An example of this is String(1337).isPalindrome.

	extension String {
		var isPalindrome: Bool {
			var testString = self

			while testString.characters.count > 1 {
				let first = testString.characters.popFirst()!
				let last = testString.characters.popLast()!
				if first != last {
					return false
				}
			}
			return true
		}
	}

## Problem 004 - Largest Palindrome Product

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

	func p004(input: Int = 999) -> Int {
		var output = 0

		while output == 0 {
			for firstNumber in stride(from: input, to: 1, by: -1) {
				if firstNumber.square < output {
					break
				}
				for secondNumber in stride(from: firstNumber, to: 1, by: -1) {
					let testNumber = firstNumber * secondNumber
					if testNumber > output && String(testNumber).isPalindrome {
						output = testNumber
					}
				}
			}
		}

		return output
	}

## Finding All Prime Factors As A Dictionary

This is similar to finding the prime factors listed above, but with a different return value. Instead of an array of Ints, this returns a Dictionary with Int keys and values. This makes adding multiple prime factors together easier.

	extension Int {
		var primeFactorsDict: [Int: Int] {
			var output: [Int: Int] = [:]
			var counter = 2
			var max = self

			while counter <= max {
				if max % counter == 0 {
					max /= counter
					if output[counter] != nil {
						output[counter]! += 1
					} else {
						output[counter] = 1
					}
				} else {
					counter += 1
				}
			}

			return output
		}
	}

## Problem 005 - Smallest Multiple

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
> 
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

	func p005(input: Int = 20) -> Int {
		var output = 1
		var factors: [Int: Int] = [:]

		for number in 2...input {
			for factor in number.primeFactorsDict {
				if factors[factor.key] == nil || factors[factor.key]! < factor.value {
					factors[factor.key] = factor.value
				}
			}
		}
		for factor in factors {
			output *= factor.key.power(by: factor.value)
		}
		return output
	}

## Problem 006 - Sum Square Difference

> The sum of the squares of the first ten natural numbers is:
1^2 + 2^2 + ... + 10^2 = 385
>
> The square of the sum of the first ten natural numbers is:
(1 + 2 + ... + 10)^2 = 55^2 = 3025
>
> Hence the difference between the sum of the squares of the first ten natural
numbers and the square of the sum is 3025 − 385 = 2640.
>
> Find the difference between the sum of the squares of the first one hundred
natural numbers and the square of the sum.

	func p006(input: Int = 100) -> Int {
		var squareSum = 0
		var sumSquare = 0

		for number in 1...input {
			squareSum += number
			sumSquare += number * number
		}

		return (squareSum * squareSum) - sumSquare
	}
