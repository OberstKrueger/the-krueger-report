---
category: programming
created: 2017-04-06T08:45Z
title: Project Euler In Swift
type: page
updated: 2018-05-02T04:00Z
---

My favorite way to learn a new programming language is using problems from [Project Euler](https://projecteuler.net). These problems are largely math problems, with a smattering of cryptography and other such topics. Many of the problems can be brute forced, but even on modern CPUs, these can take minutes or hours to solve. To truly solve the problem, one must come up with an efficient algorithm, and most are solvable in only a few seconds of time.

My goal is to work on one problem from Project Euler every week. I will post my code on this page. The code will be formatted so that each bit can function independently. A good way to see this is to load it into [Swift Playgrounds](https://developer.apple.com/swift/playgrounds/) or [Xcode](https://en.wikipedia.org/wiki/Xcode) and run the code.

Note: The problems, as presented by Project Euler, have definitive inputs with a single desired output. Despite this, I still setup my code in the form of functions that can be generalized with any input and still provide the appropriate answer.

## Problem 001 - Multiples Of 3 And 5

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

	func p001(input: Int = 1_000) -> Int {

		return stride(from: 3, to: input, by: 3).reduce(0, +) +
			stride(from: 5, to: input, by: 5).reduce(0, +) +
			stride(from: 15, to: input, by: 15).reduce(0, -)

	}

## Problem 002 - Even Fibonacci Numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci Sequence whose values do not exceed four million, find the sum of the even-valued terms.

	func p002(input: Int = 4_000_000) -> Int {
		var output: Int = 0
		var number1: Int = 0
		var number2: Int = 2

		while number2 < input {
			output += number2
			(number1, number2) = (number2, (4 * number2) + number1)
		}

		return output
	}

## Primality Check

Determining [primality](https://en.wikipedia.org/wiki/Prime_number) of a number is one of the basics in Project Euler. Problem 003 is the first to deal with prime numbers, and while this Extension is not used in my solution, it is something that sets up my solution. This function will be used heavily later on in Project Euler.

	extension Int {
		var isPrime: Bool {
			if self <= 1 { return false }
			if self % 2 == 0 { return self == 2 }
			if self % 3 == 0 { return self == 3 }
			let r = Int(sqrt(Double(self)))
			var f: Int = 5
			while f <= r {
				if self % f == 0 || self % (f + 2) == 0 { return false }
				f += 6
			}
			return true
		}
	}

## Find All Prime Factors Of A Number

This is necessary for Problem 003. This code returns an Array of Ints that includes all [prime factors](https://en.wikipedia.org/wiki/Prime_factor) of the tested number. It is implemented as an extension of the Int type, so that any Int can easily return its own prime factors using the example syntax 42.primeFactors or number.primeFactors.

	extension Int {
		var primeFactors: [Int] {
			var output: [Int] = []
			var counter: Int = 2
			var max = self

			while counter <= max {
				if max % counter == 0 {
					max /= counter
					output.append(counter)
				} else {
					counter += 1
				}
			}

			return output
		}
	}

## Problem 003 - Largest Prime Factor

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143?

	func p003(input: Int = 600_851_475_143) -> Int {

		if let number = input.primeFactors.last { return number }
		else { return 0 }

	}

## Testing Whether A String Is A Palindrome

Figuring out whether a string is a [palindrome](https://en.wikipedia.org/wiki/Palindrome) is necessary for Problem 004. This String Extension compares the string's first and last characters, pair by pair. The result is delivered as a Boolean. Any string can be checked as a palindrome by invoking the syntax word.isPalindrome. Ints can be checked by casting the Int as a String. An example of this is String(1337).isPalindrome.

	extension String {
		var isPalindrome: Bool {
			return self == String(self.characters.reversed())
		}
	}

## Finding Square Of An Integer

The square number of an integer is simply the integer times itself once. It is a simple calculation, but one that I prefer to put in an Extension just to make sure later code is a little cleaner.

	extension Int {
		var square: Int {
			return self * self
		}
	}

## Problem 004 - Largest Palindrome Product

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

	func p004(input: Int = 999) -> Int {
		var output: Int = 0

		while output == 0 {
			for firstNumber: Int in stride(from: input, to: 1, by: -1) {
				if firstNumber.square < output {
					break
				}
				for secondNumber: Int in stride(from: firstNumber, to: 1, by: -1) {
					let testNumber: Int = firstNumber * secondNumber
					if testNumber > output && String(testNumber).isPalindrome {
						output = testNumber
					}
				}
			}
		}

		return output
	}

## Finding The Power Of A Number

Having a function for finding the [exponential power](https://en.wikipedia.org/wiki/Exponentiation) of a number is not necessary, but it does help clean up and simplify functions that make use of it.

	extension Int {
		func power(by: Int = 1) -> Int {
			if by <= 0 { return 1 }

			var counter = by
			var output = self

			while counter > 1 {
				counter -= 1
				output *= self
			}

			return output
		}
	}

## Problem 005 - Smallest Multiple

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
>
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

	func p005(input: Int = 20) -> Int {
		var output: Int = 1
		var primeFactors: [Int: Int] = [:]

		for number: Int in 2...input {
			if number.isPrime {
				primeFactors[number] = 1
			} else {
				var tempFactors: [Int: Int] = [:]
				for factor: Int in number.primeFactors {
					if tempFactors[factor] == nil {
						tempFactors[factor] = 1
					} else {
						tempFactors[factor]! += 1
					}
				}
				for factor: (key: Int, value: Int) in tempFactors {
					if primeFactors[factor.key]! < factor.value {
						primeFactors[factor.key] = factor.value
					}
				}
			}
		}
		for factor: (key: Int, value: Int) in primeFactors {
			output *= factor.key.power(by: factor.value)
		}
		return output
	}

## Problem 006 - Sum Square Difference

> The sum of the squares of the first ten natural numbers is:
1^2 + 2^2 + ... + 10^2 = 385
>
> The square of the sum of the first ten natural numbers is:
(1 + 2 + ... + 10)^2 = 55^2 = 3025
>
> Hence the difference between the sum of the squares of the first ten natural
numbers and the square of the sum is 3025 − 385 = 2640.
>
> Find the difference between the sum of the squares of the first one hundred
natural numbers and the square of the sum.

	func p006(input: Int = 100) -> Int {
		let squareSum: Int = stride(from: 1, to: input + 1, by: 1).reduce(0, +)
		let sumSquare: Int = stride(from: 1, to: input + 1, by: 1).reduce(0, {$0 + $1 * $1})

		return squareSum.square - sumSquare
	}

## Problem 007 - 10001st Prime

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
>
> What is the 10,001st prime number?

	func p007(input: Int = 10_001) -> Int {
		var output: Int = 0
		var counter: Int = 0
		var number: Int = 1

		while counter < input {
			number += 1
			if number.isPrime {
				output = number
				counter += 1
			}

		}

		return output
	}

## Problem 008 - Largest Product In A Series

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
>
> 73167176531330624919225119674426574742355349194934
> 96983520312774506326239578318016984801869478851843
> 85861560789112949495459501737958331952853208805511
> 12540698747158523863050715693290963295227443043557
> 66896648950445244523161731856403098711121722383113
> 62229893423380308135336276614282806444486645238749
> 30358907296290491560440772390713810515859307960866
> 70172427121883998797908792274921901699720888093776
> 65727333001053367881220235421809751254540594752243
> 52584907711670556013604839586446706324415722155397
> 53697817977846174064955149290862569321978468622482
> 83972241375657056057490261407972968652414535100474
> 82166370484403199890008895243450658541227588666881
> 16427171479924442928230863465674813919123162824586
> 17866458359124566529476545682848912883142607690042
> 24219022671055626321111109370544217506941658960408
> 07198403850962455444362981230987879927244284909188
> 84580156166097919133875499200524063689912560717606
> 05886116467109405077541002256983155200055935729725
> 71636269561882670428252483600823257530420752963450
>
> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

*Note: The above number is entered as a String from a separate file due to size.*

	func p008(input: String = p008_input) -> Int {
		var output: Int = 0
		var currentNumbers: [Int] = []
		var numberArray: [Int] = []

		for character: Character in input.characters {
			if let number = Int(String(character)) {
				numberArray.append(number)
			}
		}
		while numberArray.count > 1 {
			var product: Int = 1
			if currentNumbers.count >= 13 {
				currentNumbers.removeFirst()
			}
			currentNumbers.append(numberArray.removeFirst())
			for number: Int in currentNumbers {
				product *= number
			}
			if product > output {
				output = product
			}
		}

		return output
	}

## Problem 009 - Special Pythagorean Triplet

> A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
>
> a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>
>
> For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.
>
> There exists exactly one Pythagorean triplet for which a + b + c = 1000.
>
> Find the product abc.

	func p009(input: Int = 1_000) -> Int {
		let halfInput = input / 2

		for number1: Int in 1..<input {
			for number2: Int in (number1 + 1)...input {
				if number2 * (number1 + number2) == halfInput {
					return (2 * number1 * number2) *
						(number2.square - number1.square) *
						(number1.square + number2.square)
				}
			}
		}

		return 0
	}

## Square Root Of An Integer

Simple extension to Int. Far from necessary due to how short it is, but keeps the double type-casting in a single spot instead of littering every place that it is needed.

	extension Int {
		var squareRoot: Int {
			return Int(sqrt(Double(self)))
		}
	}

## Finding Primes Using The Sieve Of Eratosthenes

The next problem can be solved quickly using the above primality check, but it presents a good opportunity to test out an algorithm for the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).

	func sieve(target: Int) -> [Int] {
		if target <= 1 { return [] }
		
		var checks: [Bool] = Array(repeating: true, count: target + 1)
		var primes: [Int] = []
		
		for number in 2...target.squareRoot {
			if checks[number] {
				primes.append(number)
				for notPrime in stride(from: number * number, to: target + 1, by: number) { checks[notPrime] = false }
			}
		}
		for number in (target.squareRoot + 1)...target {
			if checks[number] { primes.append(number) }
		}
		
		return primes
	}

## Problem 010 - Summation Of Primes

> The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
> 
> Find the sum of all the primes below two million.

	func p010(input: Int = 2_000_000) -> Int {
		return sieve(target: input).reduce(0, +)
	}

## Problem 011 - Largest Product In A Grid

> In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
> 
> 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
> 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
> 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
> 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
> 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
> 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
> 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
> 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
> 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
> 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
> 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
> 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
> 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
> 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
> 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
> 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
> 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
> 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
> 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
> 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
> 
> The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
> 
> What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?

*Note: The above grid is entered as an Array of an Array of Ints.*

	func p011(input: [[Int]] = p011_input) -> Int {
		let xMax: Int = input[0].count - 1
		let yMax: Int = input.count - 1
		var output: Int = 0
	
		for yIndex: Int in 0...yMax {
			for xIndex: Int in 0...xMax {
				if yIndex <= yMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex + 1][xIndex] * input[yIndex + 2][xIndex] * input[yIndex + 3][xIndex]
					if possibleTotal > output { output = possibleTotal }
				}
				if xIndex <= xMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex][xIndex + 1] * input[yIndex][xIndex + 2] * input[yIndex][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
				if yIndex <= yMax - 3 && xIndex <= xMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex + 1][xIndex + 1] * input[yIndex + 2][xIndex + 2] * input[yIndex + 3][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
				if yIndex >= 3 && xIndex <= xMax - 3 { //
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex - 1][xIndex + 1] * input[yIndex - 2][xIndex + 2] * input[yIndex - 3][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
			}
		}
	
		return output
	}

## Triangular Numbers

[Triangular numbers](https://en.wikipedia.org/wiki/Triangular_number) are numbers are calculated by counting up from 1 and adding all of the previous numbers together. The first triangular number is 1, the second triangular number is 1 + 2, the third triangular number is 1 + 2 + 3, etc. A faster method of counting triangular numbers is to use the following algorithm, passing the n<sup>th</sup> digit that you want to find:

	func triangleNumber(_ number: Int) -> Int {
		return (number * (number + 1)) / 2
	}

## Finding Factors of an Integer

The below code finds the [factors](https://en.wikipedia.org/wiki/Divisor) for any integer.

	extension Int {
		var factors: [Int] {
			var output: [Int] = self >= 1 ? [1, self] : []
			for prime in Set(self.primeFactors) {
				output += (Array(Swift.stride(from: prime, to: self, by: prime).filter({self % $0 == 0})))
			}
			return Array(Set(output)).sorted()
		}
	}

## Counting Factors

For most purposes, using the amount code and counting the numbers in the array is sufficient for figuring out the amount of factors for any number. For Problem 012, a more efficient method of counting factors is necessary, as millions of factorizations are necessary to find the answer. The following code uses the above primeFactors extension to accomplish a faster method of counting factors:

	extension Int {
		var factorCount: Int {
			if self <= 0 { return 0 }
			let factors: [Int] = self.primeFactors
			var output: Int = 1
			for prime in Set(factors) {
				output *= factors.filter({$0 == prime}).count + 1
			}
			return output
		}
	}

## Problem 012 - Highly Divisible Triangular Number

> The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
> 
> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
> 
> Let us list the factors of the first seven triangle numbers:
> 
> 1: 1
> 3: 1,3
> 6: 1,2,3,6
> 10: 1,2,5,10
> 15: 1,3,5,15
> 21: 1,3,7,21
> 28: 1,2,4,7,14,28
> 
> We can see that 28 is the first triangle number to have over five divisors.
> 
> What is the value of the first triangle number to have over five hundred divisors?

	func p012(_ input: Int = 500) -> Int {
		var counter: Int = 0
		while triangleNumber(counter).factorCount < input { counter += 1 }
	
		return triangleNumber(counter)
	}

## Problem 013 - Large Sum

> Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
> 
> 37107287533902102798797998220837590246510135740250
> 46376937677490009712648124896970078050417018260538
> 74324986199524741059474233309513058123726617309629
> 91942213363574161572522430563301811072406154908250
> 23067588207539346171171980310421047513778063246676
> 89261670696623633820136378418383684178734361726757
> 28112879812849979408065481931592621691275889832738
> 44274228917432520321923589422876796487670272189318
> 47451445736001306439091167216856844588711603153276
> 70386486105843025439939619828917593665686757934951
> 62176457141856560629502157223196586755079324193331
> 64906352462741904929101432445813822663347944758178
> 92575867718337217661963751590579239728245598838407
> 58203565325359399008402633568948830189458628227828
> 80181199384826282014278194139940567587151170094390
> 35398664372827112653829987240784473053190104293586
> 86515506006295864861532075273371959191420517255829
> 71693888707715466499115593487603532921714970056938
> 54370070576826684624621495650076471787294438377604
> 53282654108756828443191190634694037855217779295145
> 36123272525000296071075082563815656710885258350721
> 45876576172410976447339110607218265236877223636045
> 17423706905851860660448207621209813287860733969412
> 81142660418086830619328460811191061556940512689692
> 51934325451728388641918047049293215058642563049483
> 62467221648435076201727918039944693004732956340691
> 15732444386908125794514089057706229429197107928209
> 55037687525678773091862540744969844508330393682126
> 18336384825330154686196124348767681297534375946515
> 80386287592878490201521685554828717201219257766954
> 78182833757993103614740356856449095527097864797581
> 16726320100436897842553539920931837441497806860984
> 48403098129077791799088218795327364475675590848030
> 87086987551392711854517078544161852424320693150332
> 59959406895756536782107074926966537676326235447210
> 69793950679652694742597709739166693763042633987085
> 41052684708299085211399427365734116182760315001271
> 65378607361501080857009149939512557028198746004375
> 35829035317434717326932123578154982629742552737307
> 94953759765105305946966067683156574377167401875275
> 88902802571733229619176668713819931811048770190271
> 25267680276078003013678680992525463401061632866526
> 36270218540497705585629946580636237993140746255962
> 24074486908231174977792365466257246923322810917141
> 91430288197103288597806669760892938638285025333403
> 34413065578016127815921815005561868836468420090470
> 23053081172816430487623791969842487255036638784583
> 11487696932154902810424020138335124462181441773470
> 63783299490636259666498587618221225225512486764533
> 67720186971698544312419572409913959008952310058822
> 95548255300263520781532296796249481641953868218774
> 76085327132285723110424803456124867697064507995236
> 37774242535411291684276865538926205024910326572967
> 23701913275725675285653248258265463092207058596522
> 29798860272258331913126375147341994889534765745501
> 18495701454879288984856827726077713721403798879715
> 38298203783031473527721580348144513491373226651381
> 34829543829199918180278916522431027392251122869539
> 40957953066405232632538044100059654939159879593635
> 29746152185502371307642255121183693803580388584903
> 41698116222072977186158236678424689157993532961922
> 62467957194401269043877107275048102390895523597457
> 23189706772547915061505504953922979530901129967519
> 86188088225875314529584099251203829009407770775672
> 11306739708304724483816533873502340845647058077308
> 82959174767140363198008187129011875491310547126581
> 97623331044818386269515456334926366572897563400500
> 42846280183517070527831839425882145521227251250327
> 55121603546981200581762165212827652751691296897789
> 32238195734329339946437501907836945765883352399886
> 75506164965184775180738168837861091527357929701337
> 62177842752192623401942399639168044983993173312731
> 32924185707147349566916674687634660915035914677504
> 99518671430235219628894890102423325116913619626622
> 73267460800591547471830798392868535206946944540724
> 76841822524674417161514036427982273348055556214818
> 97142617910342598647204516893989422179826088076852
> 87783646182799346313767754307809363333018982642090
> 10848802521674670883215120185883543223812876952786
> 71329612474782464538636993009049310363619763878039
> 62184073572399794223406235393808339651327408011116
> 66627891981488087797941876876144230030984490851411
> 60661826293682836764744779239180335110989069790714
> 85786944089552990653640447425576083659976645795096
> 66024396409905389607120198219976047599490197230297
> 64913982680032973156037120041377903785566085089252
> 16730939319872750275468906903707539413042652315011
> 94809377245048795150954100921645863754710598436791
> 78639167021187492431995700641917969777599028300699
> 15368713711936614952811305876380278410754449733078
> 40789923115535562561142322423255033685442488917353
> 44889911501440648020369068063960672322193204149535
> 41503128880339536053299340368006977710650566631954
> 81234880673210146739058568557934581403627822703280
> 82616570773948327592232845941706525094512325230608
> 22918802058777319719839450180888072429661980811197
> 77158542502016545090413245809786882778948721859617
> 72107838435069186155435662884062257473692284509516
> 20849603980134001723930671666823555245252804609722
> 53503534226472524250874054075591789781264330331690

	import Foundation

	func p013(_ input: [String] = p013_input) -> String {
		let output: String = input.reduce(Decimal(0), {$0 + Decimal(string: $1)!}).description
		return output.prefix(10).description
	}

## Problem 014 - Longest Collatz Sequence

> The following iterative sequence is defined for the set of positive integers:
> 
> n → n/2 (n is even)
> n → 3n + 1 (n is odd)
> 
> Using the rule above and starting with 13, we generate the following sequence:
> 
> 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
> It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
> 
> Which starting number, under one million, produces the longest chain?
> 
> NOTE: Once the chain starts the terms are allowed to go above one million.

	struct collatzStruct {
		var counts: [Int: Int] = [1:1]

		mutating func collatzCount(_ input: Int) -> Int {
			if counts.keys.contains(input) == false {
				if input % 2 == 0 {
					counts[input] = collatzCount(input / 2) + 1
				} else {
					counts[input] = collatzCount(((3 * input) + 1) / 2) + 2
				}
			}

			return counts[input, default: 0]
		}

		mutating func collatzSequence(_ input: Int) -> [Int] {
			var number: Int = input
			var output: [Int] = [input]

			while number != 1 {
				if number % 2 == 0 { number = number / 2 }
				else { number = (3 * number) + 1 }
				output.append(number)
			}

			if counts.keys.contains(output.count) == false {
				counts[input] = output.count
			}

			return output
		}
	}

	func p014(_ input: Int = 1_000_000) -> Int {
		var ccs = collatzStruct()
		var highCount: Int = 0
		var output: Int = 0

		for number in stride(from: input - 1, to: input / 2, by: -2) {
			let testCount: Int = ccs.collatzCount(number)
			if testCount > highCount {
				highCount = testCount
				output = number
			}
		}

		return output
	}

## Problem 015 - Lattice Paths

> Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
> 
> How many such routes are there through a 20×20 grid?

	func p015(_ input: Int = 20) -> Int {
		return (1...input).reduce(1, {$0 * (input + $1) / $1})
	}

## Problem 016 - Power Digit Sum

> 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
> 
> What is the sum of the digits of the number 2^1000?

	import Foundation

	func p016(_ input: Int = 1_000) -> Int {
	    var carryOver: UInt8 = 0
	    var digits: [UInt8] = [1]

	    for _ in 1...input {
	        for index in 0..<digits.endIndex {
	            digits[index] = (digits[index] * 2) + carryOver
	            if digits[index] >= 10 {
	                digits[index] -= 10
	                carryOver = 1
	            } else {
	                carryOver = 0
	            }
	        }
	        if carryOver > 0 {
	            digits.append(carryOver)
	            carryOver = 0
	        }
	    }

	    return digits.reduce(0, {$0 + Int($1)})
	}
