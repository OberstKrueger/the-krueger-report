---
category: programming
created: 2017.04.06:0845
title: The Krueger Report - Project Euler In Swift
type: page
updated: 2017.08.08:0700
---

# Project Euler In Swift

My favorite way to learn a new programming language is using problems from [Project Euler](https://projecteuler.net). These problems are largely math problems, with a smattering of cryptography and other such topics. Many of the problems can be brute forced, but even on modern CPUs, these can take minutes or hours to solve. To truly solve the problem, one must come up with an efficient algorithm, and most are solvable in only a few seconds of time.

My goal is to work on one problem from Project Euler every week. I will post my code on this page. The code will be formatted so that each bit can function independently. A good way to see this is to load it into [Swift Playgrounds](https://developer.apple.com/swift/playgrounds/) or [Xcode](https://en.wikipedia.org/wiki/Xcode) and run the code.

Note: The problems, as presented by Project Euler, have definitive inputs with a single desired output. Despite this, I still setup my code in the form of functions that can be generalized with any input and still provide the appropriate answer.

## Problem 001 - Multiples Of 3 And 5

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

	func p001(input: Int = 1_000) -> Int {

		return stride(from: 3, to: input, by: 3).reduce(0, +) +
			stride(from: 5, to: input, by: 5).reduce(0, +) +
			stride(from: 15, to: input, by: 15).reduce(0, -)

	}

## Problem 002 - Even Fibonacci Numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci Sequence whose values do not exceed four million, find the sum of the even-valued terms.

	func p002(input: Int = 4_000_000) -> Int {
		var output: Int = 0
		var number1: Int = 0
		var number2: Int = 2

		while number2 < input {
			output += number2
			(number1, number2) = (number2, (4 * number2) + number1)
		}

		return output
	}

## Primality Check

Determining [primality](https://en.wikipedia.org/wiki/Prime_number) of a number is one of the basics in Project Euler. Problem 003 is the first to deal with prime numbers, and while this Extension is not used in my solution, it is something that sets up my solution. This function will be used heavily later on in Project Euler.

	extension Int {
		var isPrime: Bool {
			if self <= 1 { return false }
			if self % 2 == 0 { return self == 2 }
			if self % 3 == 0 { return self == 3 }
			let r = Int(sqrt(Double(self)))
			var f: Int = 5
			while f <= r {
				if self % f == 0 || self % (f + 2) == 0 { return false }
				f += 6
			}
			return true
		}
	}

## Find All Prime Factors Of A Number

This is necessary for Problem 003. This code returns an Array of Ints that includes all [prime factors](https://en.wikipedia.org/wiki/Prime_factor) of the tested number. It is implemented as an extension of the Int type, so that any Int can easily return its own prime factors using the example syntax 42.primeFactors or number.primeFactors.

	extension Int {
		var primeFactors: [Int] {
			var output: [Int] = []
			var counter: Int = 2
			var max = self

			while counter <= max {
				if max % counter == 0 {
					max /= counter
					output.append(counter)
				} else {
					counter += 1
				}
			}

			return output
		}
	}

## Problem 003 - Largest Prime Factor

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143?

	func p003(input: Int = 600_851_475_143) -> Int {

		if let number = input.primeFactors.last { return number }
		else { return 0 }

	}

## Testing Whether A String Is A Palindrome

Figuring out whether a string is a [palindrome](https://en.wikipedia.org/wiki/Palindrome) is necessary for Problem 004. This String Extension compares the string's first and last characters, pair by pair. The result is delivered as a Boolean. Any string can be checked as a palindrome by invoking the syntax word.isPalindrome. Ints can be checked by casting the Int as a String. An example of this is String(1337).isPalindrome.

	extension String {
		var isPalindrome: Bool {
			return self == String(self.characters.reversed())
		}
	}

## Finding Square Of An Integer

The square number of an integer is simply the integer times itself once. It is a simple calculation, but one that I prefer to put in an Extension just to make sure later code is a little cleaner.

	extension Int {
		var square: Int {
			return self * self
		}
	}

## Problem 004 - Largest Palindrome Product

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

	func p004(input: Int = 999) -> Int {
		var output: Int = 0

		while output == 0 {
			for firstNumber: Int in stride(from: input, to: 1, by: -1) {
				if firstNumber.square < output {
					break
				}
				for secondNumber: Int in stride(from: firstNumber, to: 1, by: -1) {
					let testNumber: Int = firstNumber * secondNumber
					if testNumber > output && String(testNumber).isPalindrome {
						output = testNumber
					}
				}
			}
		}

		return output
	}

## Finding The Power Of A Number

Having a function for finding the [exponential power](https://en.wikipedia.org/wiki/Exponentiation) of a number is not necessary, but it does help clean up and simplify functions that make use of it.

	extension Int {
		func power(by: Int = 1) -> Int {
			if by <= 0 { return 1 }

			var counter = by
			var output = self

			while counter > 1 {
				counter -= 1
				output *= self
			}

			return output
		}
	}

## Problem 005 - Smallest Multiple

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
>
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

	func p005(input: Int = 20) -> Int {
		var output: Int = 1
		var primeFactors: [Int: Int] = [:]

		for number: Int in 2...input {
			if number.isPrime {
				primeFactors[number] = 1
			} else {
				var tempFactors: [Int: Int] = [:]
				for factor: Int in number.primeFactors {
					if tempFactors[factor] == nil {
						tempFactors[factor] = 1
					} else {
						tempFactors[factor]! += 1
					}
				}
				for factor: (key: Int, value: Int) in tempFactors {
					if primeFactors[factor.key]! < factor.value {
						primeFactors[factor.key] = factor.value
					}
				}
			}
		}
		for factor: (key: Int, value: Int) in primeFactors {
			output *= factor.key.power(by: factor.value)
		}
		return output
	}

## Problem 006 - Sum Square Difference

> The sum of the squares of the first ten natural numbers is:
1^2 + 2^2 + ... + 10^2 = 385
>
> The square of the sum of the first ten natural numbers is:
(1 + 2 + ... + 10)^2 = 55^2 = 3025
>
> Hence the difference between the sum of the squares of the first ten natural
numbers and the square of the sum is 3025 − 385 = 2640.
>
> Find the difference between the sum of the squares of the first one hundred
natural numbers and the square of the sum.

	func p006(input: Int = 100) -> Int {
		let squareSum: Int = stride(from: 1, to: input + 1, by: 1).reduce(0, +)
		let sumSquare: Int = stride(from: 1, to: input + 1, by: 1).reduce(0, {$0 + $1 * $1})

		return squareSum.square - sumSquare
	}

## Problem 007 - 10001st Prime

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
>
> What is the 10,001st prime number?

	func p007(input: Int = 10_001) -> Int {
		var output: Int = 0
		var counter: Int = 0
		var number: Int = 1

		while counter < input {
			number += 1
			if number.isPrime {
				output = number
				counter += 1
			}

		}

		return output
	}

## Problem 008 - Largest Product In A Series

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
>
> 73167176531330624919225119674426574742355349194934
> 96983520312774506326239578318016984801869478851843
> 85861560789112949495459501737958331952853208805511
> 12540698747158523863050715693290963295227443043557
> 66896648950445244523161731856403098711121722383113
> 62229893423380308135336276614282806444486645238749
> 30358907296290491560440772390713810515859307960866
> 70172427121883998797908792274921901699720888093776
> 65727333001053367881220235421809751254540594752243
> 52584907711670556013604839586446706324415722155397
> 53697817977846174064955149290862569321978468622482
> 83972241375657056057490261407972968652414535100474
> 82166370484403199890008895243450658541227588666881
> 16427171479924442928230863465674813919123162824586
> 17866458359124566529476545682848912883142607690042
> 24219022671055626321111109370544217506941658960408
> 07198403850962455444362981230987879927244284909188
> 84580156166097919133875499200524063689912560717606
> 05886116467109405077541002256983155200055935729725
> 71636269561882670428252483600823257530420752963450
>
> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

*Note: The above number is entered as a String from a separate file due to size.*

	func p008(input: String = p008_input) -> Int {
		var output: Int = 0
		var currentNumbers: [Int] = []
		var numberArray: [Int] = []

		for character: Character in input.characters {
			if let number = Int(String(character)) {
				numberArray.append(number)
			}
		}
		while numberArray.count > 1 {
			var product: Int = 1
			if currentNumbers.count >= 13 {
				currentNumbers.removeFirst()
			}
			currentNumbers.append(numberArray.removeFirst())
			for number: Int in currentNumbers {
				product *= number
			}
			if product > output {
				output = product
			}
		}

		return output
	}

## Problem 009 - Special Pythagorean Triplet

> A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
>
> a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>
>
> For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.
>
> There exists exactly one Pythagorean triplet for which a + b + c = 1000.
>
> Find the product abc.

	func p009(input: Int = 1_000) -> Int {
		let halfInput = input / 2

		for number1: Int in 1..<input {
			for number2: Int in (number1 + 1)...input {
				if number2 * (number1 + number2) == halfInput {
					return (2 * number1 * number2) *
						(number2.square - number1.square) *
						(number1.square + number2.square)
				}
			}
		}

		return 0
	}

## Square Root Of An Integer

Simple extension to Int. Far from necessary due to how short it is, but keeps the double type-casting in a single spot instead of littering every place that it is needed.

	extension Int {
		var squareRoot: Int {
			return Int(sqrt(Double(self)))
		}
	}

## Finding Primes Using The Sieve Of Eratosthenes

The next problem can be solved quickly using the above primality check, but it presents a good opportunity to test out an algorithm for the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).

	func sieve(target: Int) -> [Int] {
		if target <= 1 { return [] }
		
		var checks: [Bool] = Array(repeating: true, count: target + 1)
		var primes: [Int] = []
		
		for number in 2...target.squareRoot {
			if checks[number] {
				primes.append(number)
				for notPrime in stride(from: number * number, to: target + 1, by: number) { checks[notPrime] = false }
			}
		}
		for number in (target.squareRoot + 1)...target {
			if checks[number] { primes.append(number) }
		}
		
		return primes
	}

## Problem 010 - Summation Of Primes

> The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
> 
> Find the sum of all the primes below two million.

	func p010(input: Int = 2_000_000) -> Int {
		return sieve(target: input).reduce(0, +)
	}

## Problem 011 - Largest Product In A Grid

> In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
> 
> 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
> 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
> 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
> 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
> 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
> 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
> 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
> 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
> 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
> 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
> 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
> 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
> 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
> 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
> 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
> 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
> 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
> 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
> 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
> 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
> 
> The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
> 
> What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?

*Note: The above grid is entered as an Array of an Array of Ints.*

	func p011(input: [[Int]] = p011_input) -> Int {
		let xMax: Int = input[0].count - 1
		let yMax: Int = input.count - 1
		var output: Int = 0
	
		for yIndex: Int in 0...yMax {
			for xIndex: Int in 0...xMax {
				if yIndex <= yMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex + 1][xIndex] * input[yIndex + 2][xIndex] * input[yIndex + 3][xIndex]
					if possibleTotal > output { output = possibleTotal }
				}
				if xIndex <= xMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex][xIndex + 1] * input[yIndex][xIndex + 2] * input[yIndex][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
				if yIndex <= yMax - 3 && xIndex <= xMax - 3 {
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex + 1][xIndex + 1] * input[yIndex + 2][xIndex + 2] * input[yIndex + 3][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
				if yIndex >= 3 && xIndex <= xMax - 3 { //
					let possibleTotal: Int = input[yIndex][xIndex] * input[yIndex - 1][xIndex + 1] * input[yIndex - 2][xIndex + 2] * input[yIndex - 3][xIndex + 3]
					if possibleTotal > output { output = possibleTotal }
				}
			}
		}
	
		return output
	}